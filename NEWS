NEWS/ChangeLog for iterors
----------------------------

1.0     2023-03-01

Split off from "async" package.
Incorporated/ported "iterators" package.
Incorporated/ported "itertools" package.
Incorporated/ported "itertools2" package.  

New features:
  o `iunique` uses a hash table rather than linear scan, for much improved
    performance; it also works with arbitrary R objects.
  o New functions `irle()` and `irle_inverse()` for run-length encoding.
  o Introduced `ireduce()`, `iaccum()`, and `sum()` and `prod()` methods for
    iterors.
  o `ichain(...)` now has a companion function `icollapse(it)` which takes
    an iterable (rather than `...`).
  o New iteror methods for `as.numeric`, `as.vector', `as.character`,
    and `as.logical`.
  o Random number iterators like `irunif`, `isample` and so on can now
    maintain a private seed value, so that interleaving with other
    iterators does not affect reproducibility. If `independent=TRUE` a
    constructed random number iterator will generate an _independent_
    pseudo-random stream (using the [nextRNGStream] mechanism).
  o New method `ienumerate.array` can iterate over
    arbitrary margins, providing you with a vector index.
  o `iwindow` constructs a sliding window of arbitrary length over a given
    iterator, generalizing `iterttools2::ipairwise` and `itripletwise`.
  o `icount` and `icountn` respect names.


Changes from the above packages:
  o `itertools2::icount(start=1, step=3, stop=15)` -> `iseq(from=1, to=15, by=3)`
    o `icount(n)` simply counts from 1 to n, and is a synonym for `iseq_len`
  o `iterators::ifilter(pred, iterable)` -> `ikeep(iterable, pred)`
  o `iterators::ifilterfalse(pred, iterable)` -> `idrop(iterable, pred)`
  o `iterators::itakewhile(pred, iterable)` -> `ikeepwhile(iterable, pred)`     
  o `iterators::idropwhile(pred, iterable)` -> `idropwhile(iterable, pred)`
  o There were conflicting definitions of `icount()`; in this package
    `icount(n)` only counts whole numbers starting with 1.
    For control over start, stop and step size use `iseq()`.
  o `irep_len` is `irep(length.out=n)`
  o There were conflicting definitions of `imap`. In this package:
    * `imap(f, ...)` maps several iterators over a function taking several
      arguments, analogous to `mapply`.
    * `iapply(iter, f, ...)` maps a single iteror over a function of one
      argument, analogous to "lapply".
  o `itertools2::iapply(array, margin)` -> `iteror(array, by=MARGIN)`
    o See also `ienumerate.array()`
  o `itertools2::iunique_lastseen()` -> `idedupe()`.
  o `consume(it, 0)` will consume zero elements. To consume the entire
    output of an iteror use `consume(it, Inf)`
  o `itertools2::iproduct` -> `igrid`
  o `icollect` is an alias / generic for `as.list`, `as.numeric`, etc.
  o `iterators::recycle` -> `irecycle`
  o There are no more `checkFunc` arguments; use `ikeep()` instead.
  o `itertools2::icycle` and `itertools::recycle` have been merged;
    the new `irecycle` uses a buffering strategy in the general case.
  o `iterors::itee` works for any iterator, using a memory buffering
    strategy, (where previously `itertools::itee` only worked for
    vector-backed iterators.
  o `itertools2::ipairwise(it)` -> `iterors::iwindow(it, 2)`
    `itertools2::itripletwise(it)` -> `iterors::iwindow(it, 2)`