NEWS/ChangeLog for iterors
----------------------------

1.0     2023-03-01

Split off from "async" package.
Incorporated/ported "iterators" package.
Incorporated/ported "itertools" package.
Incorporated/ported "itertools2" package.  

New methods:
  * `ienumerate.array` can iterate over arbitrary margins, providing you
    with a vector index.
  * `iwindow` constructs a sliding window of arbitrary length over a given
    iterator, generalizing `itertools2::ipairwise` and `itripletwise`.
  * New functions `irle()` and `irle_inverse()` for run-length encoding.
  * Introduced accumulation methods `iaccum()`, `ireduce()`, and `sum()`
    and `prod()`.
  * `ichain(...)` has a companion function `icollapse(it)` which accepts
    an iterable (rather than `...`).
  * New iteror methods for `as.numeric`, `as.vector', `as.character`,
    and `as.logical`.
  * `icollect` is an alias / generic for `as.list`, `as.numeric`, etc.

New features:
  * Memory-backed and counting iterors `icount`, `icountn`, `idiv`,
    `igrid`, `iseq`, `ienumerate.default`, `iteror.default`,
    `iteror.data.frame`, `iteror.default` and `ienumerate.array`
    all have shared logic; all accept options `chunks`, `chunksize`
    and `recycle` with equivalent behavior.
  * Meanwhile `checkFunc` arguments have been removed; instead use `ikeep()`.
  * `icount` and `icountn` preserve dimnames.
  * Multidimensional iterators `icountn`, `igrid`, `ienumerate.array` and
    `iteror.array` have option `rowMajor` to control the order of iteration.
  * `iunique` uses a hash table rather than linear scan, for much improved
    performance; it also works with any type of R object.
  * Random number iterators like `irunif`, `isample` and friends
    accept option `independent`; if TRUE, the iterator will maintain a
    private seed value, so that interleaving with other iterators does
    not affect reproducibility. By default iterors with `independent=TRUE`
    will start with a seed generated by a global `iRNGStream` instance
    so that parallel iterors will produce pseudo-independent streams.
  * `itee` works for any iterator, using a memory buffering
    strategy, where previously `itertools::itee` only worked for
    memory-backed iterators.

If you are coming from iterators/itertools/itertools2, all
functionality should be preserved, but some may be under different
names. Here's a translation guide:

  * `iterators::iapply(array, margin)` -> `iteror(array, by=margin)`
  * `iterators::recycle` -> `irecycle`
  * `itertools::ifilter(pred, iterable)` -> `ikeep(iterable, pred)`
  * `itertools::ifilterfalse(pred, iterable)` -> `idrop(iterable, pred)`
  * `itertools::isplitCols(obj, ...)` -> `iteror.array(obj, by="column", ...)`
  * `itertools::isplitIndices(n, ...)` -> `icount(n, ...)`
  * `itertools::isplitRows(obj, ...)` -> `iteror.array(obj, by="row", ...)`
  * `itertools::isplitVector(n, )` -> `iteror.default(n, ...)`
  * `itertools::product` -> `igrid`
  * `itertools::recycle` -> `irecycle`
  * `itertools::timeout(secs)` -> itimeout(secs)
  * `itertools2::icount(start=1, step=3, stop=15)` -> `iseq(from=1, to=15, by=3)`
  * `itertools2::icycle` -> `irecycle`
  * `itertools2::idropwhile(pred, iterable)` -> `idropwhile(iterable, pred)`
  * `itertools2::ifilter(pred, iterable)` -> `ikeep(iterable, pred)`
  * `itertools2::ifilterfalse(pred, iterable)` -> `idrop(iterable, pred)`
  * `itertools2::imap(f, it)` -> `iapply(it, f)`
                                 or `imap(f, it1, it2, ...)` (multiple iterables)
  * `itertools2::ipairwise(it)` -> `iwindow(it, 2)`
  * `itertools2::iproduct` -> `igrid`
  * `itertools2::irep_len` -> `irep(length.out=n)`
  * `itertools2::iseq_len` -> `icount`
  * `itertools2::iseq_along(x)` -> `icount(length(x))`
  * `itertools2::itakewhile(pred, iterable)` -> `ikeepwhile(iterable, pred)`     
  * `itertools2::itripletwise(it)` -> `iwindow(it, 3)`
  * `itertools2::iunique_lastseen()` -> `idedupe()`

