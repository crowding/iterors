% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ichunk.R
\name{i_chunk}
\alias{i_chunk}
\title{Create a chunking iterator}
\usage{
i_chunk(iterable, size, mode = "list", fill, ...)
}
\arguments{
\item{iterable}{Iterable to iterate over.}

\item{size}{Maximum number of values from \code{iterable} to return
in each value issued by the resulting iterator.}

\item{mode}{Mode of the objects returned by the iterator.}

\item{fill}{Value to use to pad the last chunk to size, if it is
short. If missing, no padding will be done.}

\item{...}{Further arguments will be forwarded to \code{iteror(iterable, ...)}.}
}
\description{
Create an iterator that issues lists of values from the underlying iterable.
This is useful for manually \dQuote{chunking} values from an iterable.
}
\examples{

# Split the vector 1:10 into "chunks" with a maximum length of three
it <- i_chunk(1:10, 3)
repeat print(unlist(nextOr(it, break)))

# Same as previous, but return integer vectors rather than lists
it <- i_chunk(1:10, 3, mode='integer')
repeat print(unlist(nextOr(it, break)))

#' it <- i_chunk(iterators::iter(1:5), 2, fill=NA)
# List: list(1, 2, 3)
nextOr(it, NULL)
# List: list(4, 5, NA)
nextOr(it, NULL)

it2 <- i_chunk(levels(iris$Species), 4, fill="weeee")
# Returns: list("setosa", "versicolor", "virginica", "weeee")
nextOr(it2, NA)

}
\seealso{
\code{iteror.default}
}
\keyword{3}
\keyword{3.5}
\keyword{4}
\keyword{Argument}
\keyword{The}
\keyword{`chunk`}
\keyword{`size`}
\keyword{a}
\keyword{alternating.}
\keyword{an}
\keyword{and}
\keyword{be}
\keyword{behavior}
\keyword{chunks}
\keyword{does}
\keyword{floating}
\keyword{for}
\keyword{instance}
\keyword{integer,}
\keyword{need}
\keyword{not}
\keyword{of}
\keyword{point}
\keyword{precise}
\keyword{precision.}
\keyword{produce}
\keyword{sizes}
\keyword{subject}
\keyword{to}
\keyword{utilities}
\keyword{will}
