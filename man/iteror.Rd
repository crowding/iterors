% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter.connection.R, R/iterators.R, R/iteror.R
\name{iteror.connection}
\alias{iteror.connection}
\alias{iteror.data.frame}
\alias{iteror}
\alias{iter}
\alias{iter.default}
\alias{iter.iter}
\alias{iter.matrix}
\alias{iter.data.frame}
\alias{iter.function}
\alias{iteror.function}
\alias{iteror.array}
\alias{iteror.matrix}
\alias{iteror.default}
\title{Iterator Factory Functions}
\usage{
\method{iteror}{connection}(obj, ...)

\method{iteror}{data.frame}(
  obj,
  by = c("column", "row"),
  ...,
  checkFunc = function(...) TRUE,
  recycle = FALSE
)

iteror(obj, ...)

\method{iteror}{`function`}(obj, ..., catch, sigil)

\method{iteror}{array}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunksize = 1L,
  recycle = FALSE,
  checkFunc = function(x) TRUE,
  drop = FALSE
)

\method{iteror}{matrix}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunksize = 1L,
  recycle = FALSE,
  checkFunc = function(x) TRUE,
  drop = FALSE
)

\method{iteror}{default}(obj, ..., recycle = FALSE, checkFunc = function(...) (TRUE))
}
\arguments{
\item{obj}{An object to iterate with. If \code{obj} is a vector, the
iterator will go over the elements of that vector and you can use
\code{recycle}.  If \code{obj} is a function, the function will be called
to compute successive elements. The function should have a leading
argument \code{or} and behave accordingly (only forcing and returning
\code{or} to signal end of iteration.)  If you provide a function that
does not have an \code{or} argument, you will need to specify either \code{catch}
or \code{sigil}.}

\item{\dots}{additional arguments affecting the iterator.}

\item{by}{how to iterate over a matrix Can be "cell", "row", "col", or
numeric dimensions.}

\item{checkFunc}{a function which, when passed an iterator value, return
\code{TRUE} or \code{FALSE}.  If \code{FALSE}, the value is skipped in the
iteration.}

\item{recycle}{a boolean describing whether the iterator should reset after
running through all it's values.}

\item{catch}{If \code{obj} is a function without an \code{or} argument, specify
e.g. \code{catch="StopIteration"} to interpret that
error message as end of iteration.}

\item{sigil}{If \code{obj} is a function without an \code{or} argument, specify
which value to watch for end of iteration. Stop will be signaled
if the function result is \code{\link[=identical]{identical()}} to \code{sigil}.}

\item{chunksize}{the number of elements of \code{by} to return with each
call to \code{nextElem}.}

\item{drop}{Whether to drop the array dimensions enumerated over.}
}
\value{
The iterator.

an object of classes 'iteror' and 'iter'.
}
\description{
\code{iter} is a generic function used to create iterator objects.
}
\examples{

# a vector iterator
i1 <- iteror(1:3)
nextOr(i1)
nextOr(i1)
nextOr(i1)

# a vector iterator with a checkFunc
i1 <- iteror(1:3, checkFunc = function(i) i\%\%2 == 0)
nextOr(i1)

# a data frame iterator by column
i2 <- iteror(data.frame(x = 1:3, y = 10, z = c("a", "b", "c")))
nextOr(i2)
nextOr(i2)
nextOr(i2)

# a data frame iterator by row
i3 <- iteror(data.frame(x = 1:3, y = 10), by = "row")
nextOr(i3)
nextOr(i3)
nextOr(i3)

# a function iterator
i4 <- iteror(function() rnorm(1), sigil=NULL)
nextOr(i4)
nextOr(i4)
nextOr(i4)

An efficient and compact iteration protocol.

To create an iteror, call the constructor `iteror` providing either
a vector or a function as argument. The returned object will
support the method [nextOr(obj, or)] to extract successive
values.

The main method for "iteror" is "nextOr" rather than
"nextElem". Instead of using exceptions, "nextOr" uses a lazily
evaluated "or" argument to signal the end of iteration.  The "or"
argument will only be forced when end of iteration is reached; this
means the consumer can provide an action like "break", "next" or
"return" to take at the the end of iteration. Summing over an
iteror this way looks like:

```
sum <- 0
it <- iteror(in)
repeat {
  val <- nextOr(iter, break)
  sum <- sum + val;
}
```

Another way to use the "or" argument is to give it a sigil value;
that is, a special value that will be interpreted as end of
iteration.  If the result of calling `nextOr` is `identical()` to
the sigil value you provided, then you know the iterator has
ended. In R it is commonplace to use `NULL` or `NA`, in the role of
a sigil, but that only works until you have an iterator that needs
to yield NULL. A safer alternative is to use a one-shot sigil
value; `new.env()` is a good choice, as it produces an object that
by construction is not [identical] to any other object in the R
session. This pattern looks like:

```
sum <- 0
stopped <- new.env()
repeat {
  val <- nextOr(iter, stopped)
  if (identical(val, stopped)) break
  sum <- sum + val
}
```

a <- array(1:8, c(2, 2, 2))

# iterate over all the slices
it <- iapply(a, by=3)
as.list(it)

# iterate over all the columns of each slice
it <- iteror(a, by=c(2, 3))
as.list(it)

# iterate over all the rows of each slice
it <- iteror(a, by=c(1, 3))
as.list(it)

}
\keyword{methods}
