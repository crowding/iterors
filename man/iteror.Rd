% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iteror.R
\name{iteror}
\alias{iteror}
\alias{iteror.function}
\alias{iteror.default}
\title{An efficient and succinct iteration protocol}
\usage{
iteror(obj, ...)

\method{iteror}{`function`}(obj, ..., catch, sigil)

\method{iteror}{default}(obj, ..., recycle = FALSE)
}
\arguments{
\item{obj}{An object to turn into an iteror. If it is a function
with a leading argument named `or` this is turned directly into
an iterator. Otherwise you must specify. If `obj` is a vector the
iterator will go over the elements of that vector}

\item{catch}{If `obj` is a function with no arguments, specify
e.g. `catch="stopIteration"` to interpret errors with that
message as end of iteration.}

\item{sigil}{If `obj` is a function with no arguments, specify
which value to watch for end of iteration. Stop will be signaled
if the function result is [identical]() to `sigil`.}

\item{recycle}{If `obj` is a vector, and `recycle` is TRUE, the
iterator will re-cycle the elements of `obj` without stopping.}
}
\description{
The "iterators" package uses stop("StopIteration") and tryCatch to
signal end of iteration, but tryCatch has a not-insiginificant
amount of overhead. In the context of a generator, when you are in a
"for" loop over an iterator, you have to be setting up and tearing
.down the trycatch on each iteration. so that you can return control
from the generator.
}
\details{
The main method for "iteror" is "nextElemOr" rather than
"nextElem". Instead of exceptions, "nextElemOr" uses a lazily
evaluated "or" argument to signal the end of iteration.  The "or"
argument is lazily evaluated, and will only be forced at the stop of
iteration; this means the consumer can provide a "break" or "return"
to respond to the end of the loop.

```
sum <- 0
it <- iterors::iteror(in)
repeat {
  val <- nextElemOr(iter, break)
  sum <- sum + val;
}
```

Another way to use the "or" argument is to give it a sigil value;
that is, a value that you know will not appear in the values
yielded by the generator. If the result of `nextElemOr` is this sigil
value, then you know the iterator has ended. In R it is commonplace
to use `NULL` or NA, as a sigil, but you do sometimes want to have
an iterator return those values literally. A generally safer
pattern is to use a one-shot sigil value; the result of `new.env()`
will work, as it returns a value that by construction is not
[identical]() to any other object in the R session.

```
stopped <- new.env()
sum <- 0
repeat {
  i <- nextElemOr(iter, stopped)
  if (identical(i, stopped)) break
  sum <- sum + i
}
```
}
