% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2_iteror.R, R/iter.connection.R,
%   R/iteror_array.R, R/iteror_data_frame.R
\name{iteror}
\alias{iteror}
\alias{iteror.default}
\alias{iteror.connection}
\alias{iteror.array}
\alias{iteror.matrix}
\alias{iteror.data.frame}
\title{Efficient, compact iteration.}
\usage{
iteror(obj, ...)

\method{iteror}{default}(obj, ..., recycle = FALSE, chunkSize, chunks)

\method{iteror}{connection}(obj, ...)

\method{iteror}{array}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunkSize,
  chunks,
  recycle = FALSE,
  drop = FALSE,
  rowMajor = TRUE
)

\method{iteror}{matrix}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunkSize,
  chunks,
  recycle = FALSE,
  drop = FALSE,
  rowMajor = TRUE
)

\method{iteror}{data.frame}(obj, ..., recycle = FALSE, chunkSize, chunks, by = c("column", "row"))
}
\arguments{
\item{obj}{An object to iterate with.}

\item{...}{Different iteror methods may take differetn options
depending on the class of \code{obj}.#' @return an object of classes
'iteror' and 'iter'.}

\item{recycle}{a boolean describing whether the iterator should reset after
running through all its values.}

\item{chunkSize}{the number of elements of \code{by} to return with
each call to \code{nextOr}.}

\item{chunks}{Split the input into this many chunks. Default \code{NA}, use \code{chunkSize}.}

\item{by}{how to split up an array or data frame. Can be "cell",
"row", "column", or numeric dimensions.}

\item{drop}{Whether to drop the array dimensions enumerated over.}

\item{rowMajor}{If TRUE, will return slices in order with the first
indices varying fastest (same as in \link{ienumerate}).}
}
\description{
\code{it <- iteror(obj, ...)} is a generic constructor that creates
objects of class "iteror" from its input. An iteror outputs a
single element of a sequence each time you call
\code{nextOr(it)}. Different \code{iteror} methods exist for different data
types and may take different optional arguments as listed in this
page.
}
\details{
When called, an iterator may either return a new value or stop. The
way an iteror signals a stop is that it does whatever you write in
the argument \code{or}. For instance you can write \code{or=break} to exit a
loop.Summing over an iteror this way looks like:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum <- 0
it <- iteror(iseq(0, 100, 7))
repeat \{
  sum <- sum + nextOr(it, break)
\}
}\if{html}{\out{</div>}}

Another way to use the "or" argument is to give it a sigil value;
that is, a special value that will be interpreted as end of
iteration.  If the result of calling \code{nextOr} is \code{identical()} to
the sigil value you provided, then you know the iterator has
ended. This pattern looks like:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum <- 0
stopped <- new.env()
it <- iteror(iseq(0, 100, 7))
repeat \{
  val <- nextOr(it, stopped)
  if (identical(val, stopped)) break
  sum <- sum + val
\}
}\if{html}{\out{</div>}}

(Note the use of new.env(). In R it is commonplace to use \code{NULL} or
\code{NA} in the role of a sigil, but that only works until you have an
iterator that needs to yield NULL itself. A safer alternative is to
use a one-shot sigil value; \code{new.env()} works for this, as it
constructs an object that is not \link{identical} to any other object in
the R session.)

Note that \code{iteror} objects are simply functions with a class
attribute attached, and all \code{nextOr.iteror} does is call the
function. So if you were in the mood, you could skip calling
\code{nextOr} through S3 dispatch and call the function directly. If you
take this approach, make sure you have called \code{iteror()} to ensure
that you have a true \code{iteror} object.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum <- 0
it <- iteror(iseq(0, 100, 7))
repeat sum <- sum + it(or=break)
sum
#> [1] 735
}\if{html}{\out{</div>}}

To create iterors with custom-defined behavior, see
\link{iteror.function}.
}
\examples{
l <- iteror(letters, chunkSize=7)
as.list(l)

a <- array(1:8, c(2, 2, 2))

# iterate over all the slices
it <- iteror(a, by=3)
as.list(it)

# iterate over all the columns of each slice
it <- iteror(a, by=c(2, 3))
as.list(it)

# iterate over all the rows of each slice
it <- iteror(a, by=c(1, 3))
as.list(it)

}
