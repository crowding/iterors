% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1_iteror.r, R/iter.connection.R, R/iterators.R
\name{iteror}
\alias{iteror}
\alias{iteror.function}
\alias{iteror.array}
\alias{iteror.matrix}
\alias{iteror.default}
\alias{iteror.connection}
\alias{iteror.data.frame}
\title{Efficient, compact iteration.}
\usage{
iteror(obj, ...)

\method{iteror}{`function`}(obj, ..., catch, sigil, count)

\method{iteror}{array}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunksize = 1L,
  recycle = FALSE,
  checkFunc = function(x) TRUE,
  drop = FALSE
)

\method{iteror}{matrix}(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunksize = 1L,
  recycle = FALSE,
  checkFunc = function(x) TRUE,
  drop = FALSE
)

\method{iteror}{default}(obj, ..., recycle = FALSE, checkFunc = function(...) (TRUE))

\method{iteror}{connection}(obj, ...)

\method{iteror}{data.frame}(
  obj,
  by = c("column", "row"),
  ...,
  checkFunc = function(...) TRUE,
  recycle = FALSE
)
}
\arguments{
\item{obj}{An object to iterate with. If \code{obj} is a vector, the
iterator will go over the elements of that vector and you can use
\code{recycle}.  If \code{obj} is a function, the function will be called
to compute successive elements. The function should have a
leading argument \code{or} and behave accordingly (only forcing and
returning \code{or} to signal end of iteration.)  If you provide a
function that does not have an \code{or} argument, you will need to
specify either \code{catch} or \code{sigil}.}

\item{...}{Extra arguments used by some \code{iteror} methods.}

\item{catch}{If \code{obj} is a function without an \code{or} argument, specify
e.g. \code{catch="StopIteration"} to interpret that
error message as end of iteration.}

\item{sigil}{If \code{obj} is a function without an \code{or} argument, specify
which value to watch for end of iteration. Stop will be signaled
if the function result is \code{\link[=identical]{identical()}} to \code{sigil}.}

\item{count}{If \code{obj} is a function without an \code{or} argument, specify
how many times to call it before finishing iteration.}

\item{by}{how to iterate over a matrix Can be "cell", "row", "col", or
numeric dimensions.}

\item{chunksize}{the number of elements of \code{by} to return with each
call to \code{nextElem}.}

\item{recycle}{a boolean describing whether the iterator should reset after
running through all it's values.}

\item{checkFunc}{a function which, when passed an iterator value, return
\code{TRUE} or \code{FALSE}.  If \code{FALSE}, the value is skipped in the
iteration.}

\item{drop}{Whether to drop the array dimensions enumerated over.}
}
\value{
an object of classes 'iteror' and 'iter'.
}
\description{
To create an iteror, call the constructor \code{iteror} providing a
function or other object as argument. The returned object will
support the method \link[=nextOr]{nextOr(obj, or)} to extract successive
values.
}
\details{
The main method for "iteror" is "nextOr" rather than
"nextElem". Instead of using exceptions, "nextOr" uses a lazily
evaluated "or" argument to signal the end of iteration.  The "or"
argument will only be forced when end of iteration is reached; this
means the consumer can provide an action like "break", "next" or
"return" to take at the the end of iteration. Summing over an
iteror this way looks like:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum <- 0
it <- iteror(iseq(0, 100, 7))
repeat \{
  sum <- sum + nextOr(it, break)
\}
}\if{html}{\out{</div>}}

Another way to use the "or" argument is to give it a sigil value;
that is, a special value that will be interpreted as end of
iteration.  If the result of calling \code{nextOr} is \code{identical()} to
the sigil value you provided, then you know the iterator has
ended. In R it is commonplace to use \code{NULL} or \code{NA} in the role of
a sigil, but that only works until you have an iterator that needs
to yield NULL itself. A safer alternative is to use a one-shot
sigil value; \code{new.env()} is a good choice, as it produces an object
that by construction is not \link{identical} to any other object in the
R session. This pattern looks like:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sum <- 0
stopped <- new.env()
it <- iteror(iseq(0, 100, 7))
repeat \{
  val <- nextOr(it, stopped)
  if (identical(val, stopped)) break
  sum <- sum + val
\}
}\if{html}{\out{</div>}}
}
\examples{
a <- array(1:8, c(2, 2, 2))

# iterate over all the slices
it <- iteror(a, by=3)
as.list(it)

# iterate over all the columns of each slice
it <- iteror(a, by=c(2, 3))
as.list(it)

# iterate over all the rows of each slice
it <- iteror(a, by=c(1, 3))
as.list(it)

}
