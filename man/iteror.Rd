% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterators.R, R/iteror.R
\name{iteror.matrix}
\alias{iteror.matrix}
\alias{iter}
\alias{iter.default}
\alias{iter.iter}
\alias{iter.matrix}
\alias{iter.data.frame}
\alias{iter.function}
\alias{iteror.data.frame}
\alias{iteror}
\alias{iteror.function}
\alias{iteror.default}
\title{Iterator Factory Functions}
\usage{
\method{iteror}{matrix}(
  obj,
  by = c("column", "cell", "row"),
  chunksize = 1L,
  checkFunc = function(...) TRUE,
  recycle = FALSE,
  ...
)

\method{iteror}{data.frame}(
  obj,
  by = c("column", "row"),
  ...,
  checkFunc = function(...) TRUE,
  recycle = FALSE
)

iteror(obj, ...)

\method{iteror}{`function`}(obj, ..., catch, sigil)

\method{iteror}{default}(obj, ..., recycle = FALSE, checkFunc = function(...) (TRUE))
}
\arguments{
\item{obj}{An object to iterate with. If `obj` is a vector, the
iterator will go over the elements of that vector and you can use
`recycle`.  If `obj` is a function, the function will be called
to compute successive elements. The function should have a leading
argument `or` and behave accordingly (only forcing and returning
`or` to signal end of iteration.)  If you provide a function that
does not have an `or` argument, you need to specify either `catch`
or `sigil`.}

\item{by}{how to iterate.}

\item{chunksize}{the number of elements of \code{by} to return with each
call to \code{nextElem}.}

\item{checkFunc}{a function which, when passed an iterator value, return
\code{TRUE} or \code{FALSE}.  If \code{FALSE}, the value is skipped in the
iteration.}

\item{recycle}{If `obj` is a vector, and `recycle` is TRUE, the
iterator will re-cycle the elements of `obj` without stopping.}

\item{\dots}{additional arguments affecting the iterator.}

\item{catch}{If `obj` is a function without an `or` argument, specify
e.g. `catch="StopIteration"` to interpret that
error message as end of iteration.}

\item{sigil}{If `obj` is a function without an `or` argument, specify
which value to watch for end of iteration. Stop will be signaled
if the function result is [identical()] to `sigil`.}
}
\value{
The iterator.

an object of classes 'iteror' and 'iter'.
}
\description{
\code{iter} is a generic function used to create iterator objects.

To create an iteror, call the constructor `iteror` providing either
a vector or a function as argument. The returned object will
support the method [nextOr(obj, or)] to extract successive
values.
}
\details{
The main method for "iteror" is "nextOr" rather than
"nextElem". Instead of using exceptions, "nextOr" uses a lazily
evaluated "or" argument to signal the end of iteration.  The "or"
argument will only be forced when end of iteration is reached; this
means the consumer can provide an action like "break", "next" or
"return" to take at the the end of iteration. Summing over an
iteror this way looks like:

```
sum <- 0
it <- iteror(in)
repeat {
  val <- nextOr(iter, break)
  sum <- sum + val;
}
```

Another way to use the "or" argument is to give it a sigil value;
that is, a special value that will be interpreted as end of
iteration.  If the result of calling `nextOr` is `identical()`
to the sigil value you provided, then you know the iterator has
ended. In R it is commonplace to use `NULL` or `NA`, in the role of
a sigil, but that only works until you have an iterator that needs
to yield NULL. A safer alternative is to use a one-shot sigil
value; the result of `new.env()` will work, as it returns a value
that by construction is not [identical] to any other object in
the R session. This pattern looks like:

```
sum <- 0
stopped <- new.env()
repeat {
  val <- nextOr(iter, stopped)
  if (identical(val, stopped)) break
  sum <- sum + val
}
```
}
\examples{

# a vector iterator
i1 <- iteror(1:3)
nextOr(i1)
nextOr(i1)
nextOr(i1)

# a vector iterator with a checkFunc
i1 <- iteror(1:3, checkFunc = function(i) i\%\%2 == 0)
nextOr(i1)

# a data frame iterator by column
i2 <- iteror(data.frame(x = 1:3, y = 10, z = c("a", "b", "c")))
nextOr(i2)
nextOr(i2)
nextOr(i2)

# a data frame iterator by row
i3 <- iteror(data.frame(x = 1:3, y = 10), by = "row")
nextOr(i3)
nextOr(i3)
nextOr(i3)

# a function iterator
i4 <- iteror(function() rnorm(1), sigil=NULL)
nextOr(i4)
nextOr(i4)
nextOr(i4)

}
\keyword{methods}
