% \VignetteIndexEntry{Writing Custom Iterators}
% \VignetteDepends{iterators}
% \VignettePackage{iterators}
\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage{xspace}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
    \usepackage[
         colorlinks=true,
         linkcolor=blue,
         citecolor=blue,
         urlcolor=blue]
         {hyperref}
         \usepackage{lscape}

\usepackage{Sweave}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define new colors for use
\definecolor{darkgreen}{rgb}{0,0.6,0}
\definecolor{darkred}{rgb}{0.6,0.0,0}
\definecolor{lightbrown}{rgb}{1,0.9,0.8}
\definecolor{brown}{rgb}{0.6,0.3,0.3}
\definecolor{darkblue}{rgb}{0,0,0.8}
\definecolor{darkmagenta}{rgb}{0.5,0,0.5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\bld}[1]{\mbox{\boldmath $#1$}}
\newcommand{\shell}[1]{\mbox{$#1$}}
\renewcommand{\vec}[1]{\mbox{\bf {#1}}}

\newcommand{\ReallySmallSpacing}{\renewcommand{\baselinestretch}{.6}\Large\normalsize}
\newcommand{\SmallSpacing}{\renewcommand{\baselinestretch}{1.1}\Large\normalsize}

\newcommand{\halfs}{\frac{1}{2}}

\setlength{\oddsidemargin}{-.25 truein}
\setlength{\evensidemargin}{0truein}
\setlength{\topmargin}{-0.2truein}
\setlength{\textwidth}{7 truein}
\setlength{\textheight}{8.5 truein}
\setlength{\parindent}{0.20truein}
\setlength{\parskip}{0.10truein}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{fancy}
\lhead{}
\chead{Writing Custom Iterators}
\rhead{}
\lfoot{}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Writing Custom Iterators}
\author{Steve Weston}
Revised for the `iterors` package by \author{Peter Meilstrup}


\begin{document}

\maketitle

\thispagestyle{empty}
\section{Introduction}

<<loadLibs,echo=FALSE,results=hide>>=
library(iterators)
@

An {\em iterator} is a special type of object that supplies data on
demand, one element\footnote{An ``element'' in this case can be basically
any object.  I don't mean to suggest that the data is necessarily returned
as scalar values, for example.} at a time.  This is a nice abstraction
that can help simplify many programs.  Iterators are particularly useful
in parallel computing, since they facilitate splitting a problem into
smaller pieces that can then be executed in parallel.

Iterators can also be used to reduce the total memory that is needed at
any one time.  For example, if you want to process the lines of text in
a file, it is common to write a loop that reads the file one line at a
time, rather than reading the entire file in order to avoid running out
of memory on huge files.  That's the basic idea of iterators.  Iterators
provide a standard method for getting the next element, which allows us
to write functions that take an iterator as an argument to provide a
source of data.  The function doesn't need to know what kind of iterator
it is.  It just needs to know how to get another piece of data.  The
data could be coming from a file, a database, a vector, or it could be
dynamically generated.

There are a number of iterators that come in the \texttt{iterators}
package.  The \texttt{iapply} function allows you to iterate over
arrays, in much the same way as the standard \texttt{apply} function.
\texttt{apply} has fixed rules on how the results are returned, which
may require you to reshape the results, which can be inefficient, as
well as inconvenient.  But since \texttt{iapply} doesn't process any
data or combine the results, it is more flexible.  You can use
\texttt{iapply} with the \texttt{foreach} package to perform a parallel
\texttt{apply} operation, and combine the results any way you want via
the \texttt{.combine} argument to \texttt{foreach}.

Another iterator that comes in the \texttt{iterators} package is the
\texttt{isplit} function, which works much like the standard
\texttt{split} function.
\texttt{split} returns a list containing all of the data divided into
groups.  \texttt{isplit} only generates one group at a time, as they are
needed, which can reduce the amount memory that is needed.

But of course, there will be times when you need an iterator that isn't
provided by the \texttt{iterators} package.  That is when you need to
write your own custom iterator.  Fortunately, that is fairly easy to do.

\section{What methods are needed for an iterator?}

Basically, an iterator is an S3 object whose base class is
\texttt{iteror}, and has \texttt{iteror} and \texttt{nextOr} methods.
The purpose of the \texttt{iteror} method is to return an iterator for
the specified object.  For iterators, that usually just means
returning itself, which seems odd at first.  But the \texttt{iteror}
method can be defined for other objects that don't define a
\texttt{nextOr} method.  We call those objects {\em iterables},
meaning that you can iterate over them.  The \texttt{iterators}
package defines \texttt{iteror} methods for vectors, lists, matrices,
and data frames, making those objects iterables.  By defining an
\texttt{iteror} method for iterators, they can be used in the same
context as an iterable, which can be convenient.  For example, the
\texttt{foreach} function takes iterables as arguments.  It calls the
\texttt{iter} method on those arguments in order to create iterators
for them.  By defining the \texttt{iteror} method for all iterators, we
can pass iterators to \texttt{foreach} that we created using any
method we choose.  Thus, we can pass vectors, lists, or iterators to
\texttt{foreach}, and they are all processed by \texttt{foreach} in
an appropriate way.

The \texttt{iterators} package comes with an \texttt{iteror} method
defined for the \texttt{iteror} class that simply returns itself.  That is
usually all that is needed for an iterator.  However, if you want to
create an iterator for some existing class, you can do that by writing
an \texttt{iteror} method that returns an appropriate iterator.  That
will allow you to pass an instance of your class to \texttt{foreach},
which will automatically convert it into an iterator.  The alternative
is to write your own function that takes arbitrary arguments, and
returns an iterator.  You can choose whichever method is most natural.

The most important method required for iterators is \texttt{nextOr}.
This simply returns the next value, or forces and returns its
\texttt{or=} argument. Returning the value of \texttt{or=} indicates
that there are no more values available in the iterator.

Now before we write our own iterator, let's try calling the
\texttt{iteror} and \texttt{nextOr} methods on an existing one.
Since a list is an iterable, we can create an iterator for that list
by calling \texttt{iteror} on it:

<<iterable1>>=
it <- iteror(list(1:2, 3:4))
@

We can now call \texttt{nextOr} on the resulting iterator to get the
values from the list:

<<iterable2>>=
nextOr(it, NULL)
nextOr(it, NULL)
nextOr(it, NULL)
@

This shows how \texttt{nextOr} behaves at the stop of iteration, returning
whatever value was given to its second argument. Here we specified NULL, but
we will later see other ways to use the second argument.

\section{A simple iterator}

It's time to show the implementation of a very simple iterator.
Although I've made it sound like you have to write your own
\texttt{iteror} and \texttt{nextOr} methods, you can inherit them.  In
fact, that's what all of the following examples do.  I do that by
inheriting from the \texttt{iteror} class.  The \texttt{iteror} class
uses a standard \texttt{iteror} method which returns itself, and
defines a \texttt{nextOr} method that calls the \texttt{nextOr}
element of the object.  Let's take a look at the implementation of
these two methods:

<<nextOr.abstractiter>>=
iterors:::iteror.iteror
iterors:::nextOr.iteror
@

Now here's a function that creates a very simple iterator that uses
these two methods:

<<iter1>>=
iforever <- function(x) {
  nextOr_ <- function(or) x
  iteror(nextOr_)
}
@

Note that I called the internal function \texttt{nextOr\_} with an underscore, rather than
\texttt{nextOr}.  I do that by convention to avoid masking the standard
\texttt{nextOr} generic function.  That causes problems when you want your
iterator to call the \texttt{nextOr} method of another iterator, which
can be quite useful, as we'll see in a later example.

We create an instance of this iterator by calling the \texttt{iforever}
function, and then use it by calling the \texttt{nextOr} method on the
resulting object:

<<runiter1>>=
it <- iforever(42)
nextOr(it)
nextOr(it)
@

You can also get values from an iterator using \texttt{as.list}.  But
since this is an infinite iterator, you need to use the \texttt{n} argument
to avoid using up a lot of memory and time:

<<runiter1.part2>>=
unlist(as.list(it, n=6))
@

Notice that it doesn't make sense to implement this iterator by defining
a new \texttt{iteror} method, since there is no natural iterable on which
to dispatch.  The only argument that we need is the object for the
iterator to return, which can be of any type.  Instead, we implement
this iterator by defining a normal function that returns the iterator.

This iterator is quite simple to implement, and possibly even
useful.\footnote{Be careful how you use this iterator!  If you pass it
to \texttt{foreach}, it will result in an infinite loop unless you pair
it with a non-infinite iterator.  Also, {\em never} pass this to the
\texttt{as.list} function without the \texttt{n} argument.} The iterator
returned by \texttt{iforever} is a list that has a single element named
\texttt{nextOr}, whose value is a function that returns the value of
\texttt{x}.  Because we are subclassing \texttt{abstractiter}, we inherit a
\texttt{nextOr} method that will call this function, and because we
are subclassing \texttt{iteror}, we inherit an \texttt{iteror} method that will
return itself.

Of course, the reason this iterator is so simple is because it doesn't
contain any state.  Most iterators need to contain some state, or it
will be difficult to make it return different values and eventually
stop.  Managing the state is usually the real trick to writing iterators.

\section{Iterators that stop}

In the general case, though, you will be dealing with effectively
finite data, but data for which you don't necessarily know the
length. So if you extract values one at a time from an iterator, you
need to handle the case where there isn't a next value. This is where
the `iterors` package improves on `iterators` by giving you a few
options for how to respond to the end of iteration.

\subsection{Breaking at the end of iteration}

If you are consuming an iterator in a loop, yhe easiest (and often
fastest) way to respond to the end of iteration so to break out of the
loop. You just put a break directly in the second argument of
\texttt{nextOr}.

<<consuming_iter_break>>=
x <- icount(10)
repeat {
  print(nextOr(x, break))
}
@

Because the \texttt{or} argument is lazily evaluated, the
texttt{break} does not execute until \texttt{nextOr} evaluates its
second argument. You can put any code into the \texttt{or} argument,
which will come in useful below.

\section{Detecting the end with a sigil}

Sometimes a break or return isn't the right action to take.  As we saw
above, \texttt{nextOr} will return its second argument (whatever that
is) to signal end of iteration, when the iterator contains no more
data. So you can check whether the returned value is the same as the
one you provided, and interpret that as the end of iteration. 

<<consuming_iter>>=
x <- icount(10)
while (!is.null(val <- nextOr(x, NULL))) {
  print(val)
}
@

Here, if \texttt{nextOr} returns \texttt{NULL}, the \texttt{while}
loop will exit. A special value used like \texttt{NULL} is used above,
is often called a \emph{sigil value}. It's popular to use NULL as a
sigil, but it's worth considering what would happen if there were an
iterator that legitimately returns \texttt{NULL} as a value. For
instance, this iterator that returns some tricky values:

<<<bad_iter>>=
bad_iter <- iteror(list(quote(.StopIteration), NULL, list(), NA, "", numeric(0)))
@ 

This is a general problem with sigil values in dynamically-typed
languages; any value you could use to signal a stop, could also be a
legitimate value for an iterator to emit.

One way out of this problem is to construct a \emph{unique} sigil
value to use locally. One easy way to create a unique value is by
using \texttt{new.env()}. Consuming an iterator using a unique sigil
value looks like this:

<<consuming_sigil>>=
end.iter <- new.env()
repeat {
while (!identical(val <- nextOr(bad_iter, end.iter), end.iter)) {
  print(val)
}
@

Because environments compare by reference, a newly constructed
environment is guaranteed not to be \texttt{identical()} to any other
object in the R session, and the check for identity is very fast (just
a pointer comparison.) By using a local, private sigil value you avoid
mistaking some other iterator's legitimate value for your signal.

\section{A stateful iterator that stops}

Let's modify the previous iterator \texttt{iforever} to stop after it
returns a certain number of values.  I'll call the new function
\texttt{irep}, and give it another argument called \texttt{times}:

<<iter2>>=
irep <- function(x, times) {
  nextOr_ <- function(or) {
    if (times > 0) {
      times <<- times - 1
      x
    } else {
      or
    }
  }

  iteror(nextOr_)
}
@

Now let's try it out:

<<runiter2>>=
it <- irep(7, 6)
unlist(as.list(it))
@

The differences between \texttt{iforever} and \texttt{irep} are in the
inner function \texttt{nextOr_} method. This inner function not only
accesses the values of the variables \texttt{x} and \texttt{times},
but it also modifies the value of \texttt{times}.  This is
accomplished by means of the ``\verb=<<-='' \footnote{It's commonly
believed that ``$<<-$'' is only used to set variables in the global
environment, but that isn't true.  I think of it as an {\em
  inheriting} assignment operator.} operator, and the rules of lexical
scoping.

After enough calls, the inner function will find \texttt{times <= 0},
and will return \texttt{or} argument. As the author of an iterator
this is how you signal end of iteration. When implementing an iterator
you never need to do anything with \texttt{or} other than return it
when appropriate; otherwise leave it alone, allowing R to be lazy in
treating that argument.

Technically, this kind of function that refers to enclosing variables
is called a {\em closure}, and is a fundamental feature of \texttt{R}.
The important thing to remember is that \texttt{nextOr_} is able to
get the value of variables that were passed as arguments to
\texttt{irep}, and it can modify those values using the ``\verb=<<-=''
operator.  These are {\em not} global variables: they are defined in
the enclosing environment of the \texttt{nextOr_} function.  You can
create as many iterators as you want using the \texttt{irep} function,
and they will all work as expected without conflicts.

Note that this iterator only uses the arguments to \texttt{irep} to
store its state.  If any other state variables are needed, they can be
defined anywhere inside the \texttt{irep} function.

\section{Using an iterator inside an iterator}

The previous section described a general way of writing custom iterators.
Almost any iterator can be written using those basic techniques.  At times, it
may be simpler to make use of an existing iterator to implement a new iterator.
Let's say that you need an iterator that splits a vector into subvectors.  That
can allow you to process the vector in parallel, but still use vector
operations, which is essential to getting good sequential performance in R.
The following function returns just such an iterator:

<<iter3>>=
ivector <- function(x, ...) {
 i <- 1
 it <- idiv(length(x), ...)

 nextOr_ <- function(or) {
   n <- nextOr(it, return(or))
   ix <- seq(i, length=n)
   i <<- i + n
   x[ix]
 }

 iteror(nextOr_)
}
@

\texttt{ivector} uses \texttt{...} to pass options on to
\texttt{idiv}.  \texttt{idiv} supports the \texttt{chunks} argument
to split its argument into a specified number of pieces, and the
\texttt{chunkSize} argument to split it into pieces of a specified
maximum size.

Let's create an \texttt{ivector} iterator to split a vector into three
pieces using the \texttt{chunks} argument:

<<runiter3>>=
it <- ivector(1:25, chunks=3)
as.list(it)
@

Note how the \texttt{nextOr_} function handles the end of iteration.
If the underlying \texttt{idiv} iterator reaches the end, it will
force \emph{its} `or` argument, which we have given as
\texttt{return(or)}, Although it is forced by the inderlying iterator,
R correctly evaluates a \texttt{return} call in a lazy argument
according to the scope it was call written in, so that this return
does the right thing, unwinding the scack to return out of
\texttt{ivector}'s \texttt{nextOr_}.

The \texttt{nextOr} function uses a lazy evaluated argument expressly for
this purpose, so that you can respond to end of iteration by using a
control flow operator like \texttt{return}, \texttt{break}, or
\texttt{next} or \texttt{stop}.

It should be clear that only minor modification need to be made to this
function to create an iterator over the blocks of rows or columns of a
matrix or data frame.  But I'll leave that as an exercise for the
reader.

\section{A recycling iterator}

You can start to compose simple iterators together to do more complex
things by writing functions that take in one iterator and construct a
new one. In this example, we'll return an iterator that recycles the
values of the wrapped iterator:\footnote{ Actually, some of the
standard \texttt{iteror} methods support a \texttt{recycle} argument.
But this is a nice example, and a more general solution, since it
works on any iterator.}

<<recyle>>=
irecycle <- function(it) {
  values <- as.list(iteror(it))
  i <- length(values)

  nextOr_ <- function(or) {
    i <<- i + 1
    if (i > length(values)) i <<- 1
    values[[i]]
  }

  iteror(nextOr_)
}
@

This is fairly nice, but note that this is another one of those
infinite iterators that we need to be careful about.  Also, make sure
that you don't pass an infinite iterator to \texttt{irecycle}.  That
would be pointless of course, since there's no reason to recycle an
iterator that never ends.  It would be possible to write this to avoid
that problem by not grabbing all of the values right up front, but you
would still end up saving values that will never be recycled, so I've
opted to keep this simple.

Let's try it out:

<<recyleexample>>=
it <- irecycle(icount(3))
unlist(as.list(it, n=9))
@

\section{Limiting infinite iterators}

I was tempted to add an argument to the \texttt{irecycle} function to
limit the number of values that it returns, because sometimes you want
to recycle for awhile, but not forever.  I didn't do that, because
rather than make \texttt{irecycle} more complicated, I decided to
write yet another function that takes an iterator and returns a
modified iterator. Functions like this are \emph{composable}; the
limiting function can be applied to any underlying iterator instead of
just `irecycle`.

<<ilimit>>=
ilimit <- function(it, times) {
  it <- iteror(it)

  nextOr_ <- function(or) {
    if (times > 0) {
      times <<- times - 1
      nextOr(it, or)
    } else
      return(or)
  }

  iteror(nextOr_)
}
@

Note that this looks an awful lot like the \texttt{irep} function that
we implemented previously.  In fact, using \texttt{ilimit}, we can
implement \texttt{irep} using \texttt{iforever} much more simply, and
without duplication of code:

<<irep2>>=
irep2 <- function(x, times)
  ilimit(iforever(x), times)
@

To demonstrate \texttt{irep2}:

<<testirep2>>=
it <- irep2('foo', 3)
repeat {
  print(nextOr(it, break))
}
@

Here's one last example.  Let's recycle a vector three times using
\texttt{ilimit}, and convert it back into a vector using
\texttt{as.list} and \texttt{unlist}:

<<testirecycle>>=
iterable <- 1:3
n <- 3
it <- ilimit(irecycle(iterable), n * length(iterable))
unlist(as.list(it))
@

Sort of a complicated version of:
<<rep>>=
rep(iterable, n)
@
Aren't iterators fun?

\section{Conclusion}

Writing your own iterators can be quite simple, and yet is very useful
and powerful.  It provides a very effective way to extend the
capabilities of other packages that use iterators, such as the
\texttt{foreach} package.  By writing iterators that wrap other
iterators, it is possible to put together a powerful and flexible set of
tools that work well together, and that can solve many of the complex
problems that come up in parallel computing.

\end{document}
