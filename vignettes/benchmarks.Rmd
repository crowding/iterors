---
title: "Benchmarking Iteration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Benchmarking Iteration}
  %\VignetteEncoding{UTF-8}
---

This document illustrates the differences in performance between `iterors` using `nextOr` style iteration and `iterators`/`itertools`/`itertools2` using `nextElem`/`tryCatch` style iteration.

```{R, include=FALSE}
library(ggplot2)
require(iterators)
require(itertools)
require(itertools2)
 library(dplyr)
plotit <- function(df) {
  library(dplyr)
  summary <- df |>
    group_by(expr) |>
    summarize(
      time.avg = median(time),
      time.uq = quantile(time, 3/4, names=FALSE),
      time.lq = quantile(time, 1/4, names=FALSE))
  ggplot(summary) +
    aes(x = time.avg, y = expr) +
    geom_bar(stat="identity", fill = "steelblue", orientation="y") +
    geom_errorbar(aes(xmin = time.lq, xmax = time.uq),
                  width = 0.4, color = "black") +
    labs(title = deparse(substitute(df)), y = "Package", x = "Time (ns)") +
    theme_minimal()
}
```

```{R, fig.asp=4}
# `collapse` is not implemented in iterators, but
# here's how you `_would_` write collapse in `tryCatch`/`nextElem` style.
iter_collapse <- with(as.environment("package:iterators"), function(obj) {
  obj <- iterators::iter(obj)
  sigil <- new.env()
  current <- sigil
  nextEl <- function(or) {
    if (identical(current, sigil)) {
      current <<- iter(nextElem(obj))
    }
    repeat {
      tryCatch({
        return(nextElem(current))
      }, error=function(err) {
        if (conditionMessage(err) == "StopIteration") {
          current <<- iter(nextElem(obj))
        } else stop(err)
      })
    }
  }
  it <- list(nextElem=nextEl)
  class(it) <- c('abstractiter', 'iter')
  it
})
#
collapse.bench <- microbenchmark::microbenchmark(
       iterators=itertools2::consume(iter_collapse(itertools2::imap(iterators::icount, iterators::icount(10)))),
       iterors=iterors::consume(iterors::icollapse(iterors::iapply(iterors::icount(10), iterors::icount))),
       times=10)
plotit(collapse.bench)
```

## `icountn` and `as.list`:
```{R, fig.asp=4}
 icountn.bench <- microbenchmark::microbenchmark(
    iterators = iterators:::as.list.iter(iterators::icountn(c(4,5,6,7))),
    iterors = iterors:::as.list.iteror(iterors::icountn(c(4,5,6,7))),
    times =10)
 plotit(icountn.bench)
```

## `ikeep`/`ifilter`
```{R, fig.asp=4}
ikeep.bench <- microbenchmark::microbenchmark(
    iterators = as.list(itertools::ifilter(\(x) floor(sqrt(x))^2 == x, iterators::icount(1000))),
    iterors = as.list(iterors::ikeep(iterors::icount(1000), \(x) floor(sqrt(x))^2 == x)),,
    times = 10)
 plotit(ikeep.bench)
```

## Iterating over a vector
```{R, fig.asp=4}
vector.bench <- microbenchmark::microbenchmark(
    iterators = itertools2::consume(iterators::iter(1:1000)),
    iterors = iterors::consume(iterors::iteror(1:1000)),
    times = 10)
  plotit(vector.bench)
```

## Chunking a vector
```{R, fig.asp=4}
chunk.bench <- microbenchmark::microbenchmark(
  itertools = itertools2::consume(itertools::isplitVector(1:6000, chunkSize=17)),
  iterors = iterors::consume(iteror(1:6000, chunkSize=17)),
  times = 10)
plotit(chunk.bench)
```

## Extracting rows or columns

```{R, fig.asp=4}
arr <- array(1:1000000, c(1000,1000))
slice.bench <- microbenchmark::microbenchmark(
  iterators.rows = itertools2::consume(iterators::iter(arr, by="row")),
  iterators.cols = itertools2::consume(iterators::iter(arr, by="column")),
  itertools.array_rows = itertools2::consume(itertools::iarray(arr, MARGIN = 1)),
  itertools.array_cols = itertools2::consume(itertools::iarray(arr,MARGIN = 2)),
  iterors.rows = iterors::consume(iteror(arr, by=1)),
  iterors.cols = iterors::consume(iteror(arr, by=2)),
times = 10)
plotit(slice.bench)
```

## Split matrix into chunks (XXX)

```{R, fig.asp=4}
arr <- array(1:1000000, c(1000,1000))
array_chunks.bench <- microbenchmark::microbenchmark(
  itertools.rows = itertools2::consume(itertools::isplitRows(arr, chunkSize=7)),
  itertools.cols = itertools2::consume(itertools::isplitCols(arr, chunkSize=7)),
  itertools.array_rows = itertools2::consume(itertools::iarray(arr, MARGIN = 1, chunkSize=7)),
  itertools.array_cols = itertools2::consume(itertools::iarray(arr,MARGIN = 2, chunkSize=7)),
  iterors.rows = iterors::consume(iteror(arr, by=1, chunkSize=7)),
  iterors.cols = iterors::consume(iteror(arr, by=2, chunkSize=7)),
times = 10)
plotit(array_chunks.bench)
```

## Extracting 3d slices of an array

```{R}
chunk.bench <- microbenchmark::microbenchmark
```

## Random number generation

When `independent=TRUE` there is extra work in saving and restoring the 
random number generator settings.
```{R, fig.asp=4}
sampling.bench <- microbenchmark::microbenchmark(
    iterators = as.list(iterators::irunif(100, count=100)),
    iterors.independent = as.list(iterors::irunif(100, count=100, independent=TRUE)),
    iterors.dependent = as.list(iterors::irunif(100, count=100, independent=FALSE)),
    times = 100)
plotit(sampling.bench)
```

## `as.list`

```{R, fig.asp=4}
as.list.bench <- microbenchmark::microbenchmark(
    iterators = as.list(iterators::icount(3000)),
    iterors = as.list(iterors::icount(3000)),
    times = 10)
plotit(as.list.bench)
```

## Select only unique values

`iterors::iunique` uses a hash table for better performance.

```{R, fig.asp=4}
iunique.bench <- microbenchmark::microbenchmark(
       iterators = {
         it <- itertools2::iunique(iterators::isample(1:100, 1))
         as.numeric(itertools2::take(it, 100))
       },
       iterors = {
         it <- iterors::iunique(iterors::isample(1:100, 1, independent=FALSE))
         iterors::take(it, 100, "numeric")
       },
       times=10)
plotit(iunique.bench)
```

## Cartesian product of vectors

```{R, fig.asp=2}
igrid.bench <- microbenchmark::microbenchmark(
  # itertools2 = itertools2::consume(itertools2::iproduct(1:10, letters, month.name)),
  itertools = itertools2::consume(itertools::product(1:10, letters, month.name)),
  itertls2 = itertools2::consume(itertools2::iproduct(1:10, letters, month.name))
  iterors = iterors::consume(iterors::igrid(1:10, letters, month.name)),
  iterors.alt = iterors::consume(iterors:::igrid2(1:10, letters, month.name)),
  times = 10)
plotit(igrid.bench)
```

## icycle / irecycle

Note that `itertools2::icycle` only works for cloneable, vector-based iterators, while the other two use a general purpose buffer.

```{R, fig.asp=4}
icycle.bench <- microbenchmark::microbenchmark(
  itertools2 = as.list(itertools2::icycle(1:20, times = 20)),
  itertools = itertools2::consume(itertools::recycle(iterators::icount(20), times = 20)),
  iterors = iterors::consume(iterors::irecycle(iterors::icount(20), times = 20)),
  times = 20)
plotit(icycle.bench)
```

## itee

Note that `itertools2::tee` only works for vetocr-based iterators it
knows how to clone, while `iterors::itee` uses a general purpose
buffering mechanism.

```{R, fig.asp=4}
itee.bench <- microbenchmark::microbenchmark(
  itertools2={
    itertools2::consume(
      do.call(itertools::chain,
        itertools2::itee(1:20, n=20)))
  },
  iterors={
    iterors::consume(
      iterors::icollapse(
        iterors::itee(iterors::icount(20), n=20)))
  },
  times=20)
plotit(itee.bench)
```

## Sliding window iterators

`iterors` uses specialized routines for n=2 and n=3. For n=4 and above, a
general purpose queue is used.

```{R, fig.asp=4}
marks=c(alist(
  itertools2.w2={itertools2::consume(itertools2::ipairwise(1:200))}),
  if (exists("itripletwise", asNamespace("itertools2"), inherits=FALSE)) {
    alist(itertools2.w3={itertools2::consume(itertools2::itripletwise(1:200))})
  },
  alist(
    iterors.w2={iterors::consume(iterors::iwindow(1:200, 2))},
    iterors.w3={iterors::consume(iterors::iwindow(1:200, 3))},
    iterors.w4={iterors::consume(iterors::iwindow(1:200, 4))},
    iterors.w50={iterors::consume(iterors::iwindow(1:200, 50))}))
iwindow.bench <- microbenchmark::microbenchmark(list=marks, times=10)
plotit(iwindow.bench)
```
